Coffeemaker.core.capacities.load = function () {

		
		var repository;
		var payload;
		var path;
		
		repository = arguments[0];
		payload = arguments[1];
		
		Array.prototype.shift.apply(arguments);
		Array.prototype.shift.apply(arguments);
		
		var engine = function (uri) {
			
			var o = Coffeemaker;
			var p = uri.split("/");

			for ( var n=0; n<p.length; n++ ) {
			    //alert(o +" "+ p[n]+ "      "+p);
			    if( ! o[p[n]] ) o[p[n]] = {};
			    if (o) o = o[p[n]];
			}
		
			return o;
		}
		
		
		if ( ! payload ) {
				
				if (repository.match('core\/capacities\/')) repository.replace('core\/capacities\/','');
				return engine('core/capacities/'+repository);

		} else {
		
		
		if ( repository === 'components' || repository === 'methods' || repository === 'templates' ) {
				var check = Coffeemaker.core.capacities.check;
				var url = repository+'/'+payload;
				
				if ( check.inArray(url,Coffeemaker.core.capacities.load.loaded) ) {

					//return Coffeemaker[repository][payload];
					return engine(url);
				
				} else {
				
					//download components and methods
					if (transmission = Coffeemaker.core.capacities.transmission.ajax) {
					
						transmission.GET( url+'.json',"",function(a){
					
								if (check.isJSON(a)) {
								 	//var repo = engine(url);
									//repo[payload] = JSON.parse(a);
									if ( ! Coffeemaker[repository] ) Coffeemaker[repository] = {};
									Coffeemaker[repository][payload] = JSON.parse(a);
								} else {
									Coffeemaker.core.capacities.log.exception(
									'load.js','JSON failed to parse',a);
								}

						});
						
						Coffeemaker.core.capacities.load.loaded.push(url);
				
					}
					
				}
			
			
			}
		
		
		}
		
}
		
Coffeemaker.core.capacities.load.loaded = []
		
//		
//		
//		
//		
//		if ( ! arguments[1] ) {
//			return Coffeemaker[repository];
//		} else {
//		
//		if ( repository !== 'components' || repository !== 'methods' ) {
//		
//			payload = (arguments[1]) ? "/"+arguments[1] : '';
//		    

//		
//			path = repository+payload;
//			p = path.split("/");

//		    for ( var n=0; n<p.length; n++ ) {
//		        //alert(o +" "+ p[n]+ "      "+p);
//		        if( ! o[p[n]] ) o[p[n]] = {};
//		        if (o) o = o[p[n]];
//		    }
//		         
//	    	return o;
//	    }
//	    
//	    else if ( repository === 'methods' || repository === 'components' ) {
//			
//			if ( ! arguments[1] ) return;
//			
//			var check = Coffeemaker.core.capacities.check;
//			payload = arguments[1];
//			
//			if ( ! check.inArray(path,Coffeemaker.core.capacities.load.loaded) ) {
//			
//				//download components and methods
//				var transmission = Coffeemaker.core.capacities.transmission.ajax;
//				
//				if (transmission) {
//					
//					//payload = (arguments[1]) ? "/"+arguments[1] : '';
//					var url = path+'.json';
//				
//					transmission.GET( url,"",function(a){
//					
//							if (check.isJSON(a)) {
//								Coffeemaker[repository][payload.substr(1)] = JSON.parse(a);
//								Coffeemaker.core.capacities.load.loaded.push(path);
//							} else {
//								Coffeemaker.core.capacities.log.exception(
//								'load.js','JSON failed to parse',a);
//							}

//					});
//				
//				}
//		
//			}
//			
//		} else {
//		
//			return Coffeemaker[repository][payload.substr(1)];
//			
//		}
//		
		
	    
		//if(o.prototype) o.prototype.arguments = arguments;



//            path = p.join("/");
//            if( ! this[component] ) {
//                var s  = document.createElement("script");
//                s.src  = r+"/"+path+"/"+component+".js";
//                document.head.appendChild(s);
//                document.head.removeChild(s);
//            }

//}



//Coffeemaker.core.process.load = function (payload,repository,opt) {
//        
//        return Coffeemaker.core.import(Coffeemaker.config.capacities,[payload]);
//        
//	//Available repo
//	repo = {};
//	repo['capacities'] = Coffeemaker.core['capacities'];
//	repo['methods'] = Coffeemaker['methods'];
//	repo['components'] = Coffeemaker['components'];

//	//Needed capacities
//	check = Coffeemaker.core.capacities.check;
//	
//	payload = Array.prototype.shift.apply(arguments);
//	repository = Array.prototype.shift.apply(arguments);
//	
//	if ( check.isObject(repo[repository]) ) {
//	
//	//Loading

//		if ( check.isObject(repo[repository][payload]) ) return repo[repository][payload];
//		return repo[repository];

//	} else {
//	
//		//setup a NOFAIL
//	
//		if ( check.isObject(repo['methods'])
//		&& check.isObject(repo['methods'][payload]) ) return repo['methods'][payload];
//		if ( check.isObject(repo['components'])
//		&& check.isObject(repo['components'][payload]) ) return repo['components'][payload];
//		if ( check.isObject(repo['capacities'])
//		&& check.isObject(repo['capacities'][payload]) ) return repo['capacities'][payload];
//	
//	}

//}
